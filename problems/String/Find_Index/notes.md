# Find the Index of the First Occurrence in a String

## 問題概要

文字列 `haystack` の中から、`needle` が最初に出現する位置（インデックス）を返す。  
一致しなければ `-1` を返す。  
空文字列の `needle` が与えられた場合は `0` を返す。

---

## 解法①：Naive法（全探索）

- `haystack` を `needle` の長さぶんずらしながら比較
- 一致しなければ次にずらす
- **時間計算量：O((n - m + 1) × m)**
- **空間計算量：O(1)**
- 実装が非常にシンプルだが、大きな入力には不向き

**注意点：**
- `needle` が空文字なら 0 を返す
- 比較は `i + j` を使って `haystack` と `needle` を順に見る

---

## 解法②：組み込み関数（find）

- Pythonの `str.find()` を使用
- **時間計算量：O(n)**（内部的には高速なアルゴリズム）
- **空間計算量：O(1)**
- 実装は1行、面接ではライブラリ利用可否に注意

**注意点：**
- `find()` は見つからないとき `-1` を返すので、そのまま使える
- 実務では非常に便利

---

## 解法③：KMP法（Knuth–Morris–Pratt）

- `needle` の中での繰り返しパターンを LPS（Longest Prefix Suffix）配列に変換
- `haystack` を1回走査しつつ、`needle` に部分一致していく
- **時間計算量：O(n + m)**
- **空間計算量：O(m)**（LPSテーブル）

**注意点：**
- LPSの構築がやや複雑だが、最悪計算量が高速で安定
- `i`, `j` をうまく操作し、部分一致を活かして比較をスキップ
- `j == len(needle)` になったら `i - j` が一致位置

---

## 学び・気づき

- Naive法は基礎理解に有効、実用にはKMPや組み込み関数
- LPS配列の理解がKMP習得のカギ
- 部分一致パターンをうまく使うと、無駄な比較を減らせる

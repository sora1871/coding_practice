# Find the Index of the First Occurrence in a String

## 問題概要

文字列 `haystack` の中から、`needle` が最初に出現する位置（インデックス）を返す。  
一致しなければ `-1` を返す。  
空文字列の `needle` が与えられた場合は `0` を返す。

---

## 解法①：Naive法（全探索）

- `haystack` を `needle` の長さぶんずらしながら比較
- 一致しなければ次にずらす
- **時間計算量：O((n - m + 1) × m)**
- **空間計算量：O(1)**
- 実装が非常にシンプルだが、大きな入力には不向き

**注意点：**
- `needle` が空文字なら 0 を返す
- 比較は `i + j` を使って `haystack` と `needle` を順に見る

---

## 解法②：組み込み関数（find）

- Pythonの `str.find()` を使用
- **時間計算量：O(n)**（内部的には高速なアルゴリズム）
- **空間計算量：O(1)**
- 実装は1行、面接ではライブラリ利用可否に注意

**注意点：**
- `find()` は見つからないとき `-1` を返すので、そのまま使える
- 実務では非常に便利

---

## 解法③：KMP法（Knuth–Morris–Pratt）

- `needle` の中での繰り返しパターンを LPS（Longest Prefix Suffix）配列に変換
- `haystack` を1回走査しつつ、`needle` に部分一致していく
- **時間計算量：O(n + m)**
- **空間計算量：O(m)**（LPSテーブル）

**注意点：**
- LPSの構築がやや複雑だが、最悪計算量が高速で安定
- `i`, `j` をうまく操作し、部分一致を活かして比較をスキップ
- `j == len(needle)` になったら `i - j` が一致位置

# KMP法：惜しい不一致が続くパターンの完全理解

## 🎯 問題例

- `haystack = "aaaabaaabaaaabaaac"`
- `needle   = "aaaabaaaac"`

---

## 🧩 LPS配列の構築

`needle` に対する LPS（Longest Prefix Suffix）配列：

| i | 部分列         | LPS[i] | 解説                             |
|--:|----------------|--------|----------------------------------|
| 0 | a              | 0      | 初期                             |
| 1 | aa             | 1      | "a" 一致                         |
| 2 | aaa            | 2      | "aa" 一致                        |
| 3 | aaaa           | 3      | "aaa" 一致                       |
| 4 | aaaab          | 0      | bで崩れる                        |
| 5 | aaaaba         | 1      | aで再一致                        |
| 6 | aaaabaa        | 2      | "aa"                             |
| 7 | aaaabaaa       | 3      | "aaa"                            |
| 8 | aaaabaaaa      | 4      | "aaaa"                           |
| 9 | aaaabaaaac     | 0      | cで崩れる                        |

➡ `LPS = [0, 1, 2, 3, 0, 1, 2, 3, 4, 0]`

---

## 🔍 KMPステップの詳細実行

完全一致：`haystack[8..17] = aaaabaaaac` と `needle` が一致。  
この間に **一度大きな不一致（i=8）と連続4回の巻き戻し**が発生する。

### 失敗直前の状態：

- `i = 8`, `j = 8`
- `haystack[8] = b`, `needle[8] = a` → ❌不一致

---

### 🌀 巻き戻しの流れ

| jの現在値 | 比較        | 結果     | 次の j        |
|-----------|-------------|----------|----------------|
| 8         | b vs a      | ❌       | j = LPS[7] = 3 |
| 3         | b vs a      | ❌       | j = LPS[2] = 2 |
| 2         | b vs a      | ❌       | j = LPS[1] = 1 |
| 1         | b vs a      | ❌       | j = LPS[0] = 0 |
| 0         | b vs a      | ❌       | j = 0, i++     |

---

## 🚫 Naive法だったら？

- 毎回 `i = 1, 2, 3...` から再スタート
- `needle` を最初から比較し直し → **10文字 × 多回で非効率**

---

## 🚀 KMPのすごさ（ここが革命）

- **一度マッチした `needle` の構造（LPS）を活用**
- `i` を戻さず、`j` をスキップ的に巻き戻すことで、**比較数を最小化**
- 不一致後も「希望のある位置」に再挑戦できる！

---

## ✅ まとめ

- `LPS[i]` が意味するのは「その時点までに部分一致していた長さ」
- 不一致が起きても `j = LPS[j-1]` にすることで、再試行を最短ルートにできる
- これがKMP法の最大の魅力：「**止まらずに前へ進む再挑戦**」

---


---

## 学び・気づき

- Naive法は基礎理解に有効、実用にはKMPや組み込み関数
- LPS配列の理解がKMP習得のカギ
- 部分一致パターンをうまく使うと、無駄な比較を減らせる

# Intersection of Two Arrays 解法まとめ

## ✅ 問題概要

2つの配列 `nums1` と `nums2` が与えられ、それぞれに含まれる共通の要素（重複なし）を配列として返す。

---

## ✅ 解法①：辞書を使って出現管理

### 手順：

1. `nums1` の値をすべて辞書に記録（`True`）
2. `nums2` をループし、もし `nums1` に含まれていれば `output` に追加
3. 一度追加したら `count[i] = False` にして、重複を防ぐ

---

### ✅ 特徴（辞書バージョン）

- `i in count and count[i] == True` を使って、**存在チェック + 重複排除**を明示的に実装
- setより少し長くなるが、**初学者にわかりやすく、保守性が高い**
- 出力順序は問われないため、順序を気にする必要はない

---

## ✅ 解法②：setを使った最速・最短バージョン
### ✅ 特徴（setバージョン）

- `set(nums1)` と `set(nums2)` を使えば、**自動的に重複が排除された集合**が得られる
- `&` 演算子は **積集合（共通部分）** を求める
- 結果を `list()` に変換すれば、要件を満たす
- 非常に簡潔で高速（O(n + m)）

---

### ✅ 計算量（共通）

- **時間計算量**：O(n + m)
- **空間計算量**：O(n)

---

### ✅ テスト例

| nums1       | nums2               | 出力              |
|-------------|---------------------|-------------------|
| [1, 2, 2, 1] | [2, 2]              | [2]               |
| [4, 9, 5]    | [9, 4, 9, 8, 4]     | [9, 4] or [4, 9]  |

---

### 🧠 補足

- `set(nums1) & set(nums2)` を使えばもっと短く書けるが、**辞書方式は柔軟性が高く拡張しやすい**
- `i in count` と `count[i]` の併用により、**誤判定が起きにくく安全**
- set方式は **Pythonに特化して非常にPythonic** だが、**他言語では辞書方式の方が応用しやすい**

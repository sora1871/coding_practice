# Valid Anagram 解法まとめ

## 問題概要
2つの文字列 `s`, `t` が与えられる。`t` が `s` のアナグラムかどうかを判定する。文字の順番は異なっていても、文字の種類と出現回数がすべて同じである必要がある。

---

## 解法①：sorted() を使う
- `sorted(s) == sorted(t)` で簡潔に判定
- 実装が非常に簡単でわかりやすい
- 時間計算量：O(n log n)、空間計算量：O(n)
- データサイズが小さいときや、面接では便利

---

## 解法②：dict.get() を使った文字数カウント
- `dict.get(i, 0)` を使って、文字ごとの出現回数を管理
- 柔軟で、英小文字以外の文字（記号、Unicode）も扱える
- 時間計算量：O(n)、空間計算量：O(k)（k=文字種類数）
- 実務や汎用的な処理に向いている

---

## 解法③：collections.defaultdict を使って簡潔に
- `defaultdict(int)` を使えば初期値処理が不要になる
- dict.get() よりもスッキリ記述でき、可読性も高い
- 処理ロジックは②と同じく、文字数の差が全て0か確認

---

## 解法④：固定長配列を使った最速解（英小文字限定）
- a〜zを [0〜25] にマッピングし、長さ26の配列でカウント
- 配列により高速化（O(n)時間、O(1)空間）
- 柔軟性はないが、文字種が固定なら最適
- 競技プログラミングや制約付きの問題で有効

---

## 解法比較まとめ
| 方法         | 実装の簡単さ | 実行速度 | 柔軟性     | 推奨シーン         |
|--------------|--------------|----------|-------------|--------------------|
| sorted       | ◎            | △        | ◎           | 面接・簡単な検証    |
| dict.get()   | ○            | ◎        | ◎           | 実務全般            |
| defaultdict  | ◎            | ◎        | ◎           | 実務・保守性重視    |
| 配列[26]     | △            | ◎        | ❌（拡張性無）| 高速・制約がある時 |

---

## 学び・気づきメモ
- Pythonの文字列はimmutable → 直接変更はできない
- get() を使えばKeyErrorを回避可能
- 固定長配列はスピードは速いが、用途が限定的

---

## 今後やるなら？
- Unicodeやマルチバイト対応バージョン
- 実行速度とメモリのベンチマーク比較
- Rustなど他言語での実装比較

# Roman to Integer

## 🔗 問題リンク
[LeetCode #13 - Roman to Integer](https://leetcode.com/problems/roman-to-integer/)

---

## 📘 問題概要

ローマ数字で書かれた文字列 `s` が与えられ、その値を整数に変換する。  
記号ごとの値は以下の通り：

| 記号 | 値  |
|------|-----|
| I    | 1   |
| V    | 5   |
| X    | 10  |
| L    | 50  |
| C    | 100 |
| D    | 500 |
| M    | 1000 |

特殊な減算ルール：
- `IV = 4`, `IX = 9`, `XL = 40`, `XC = 90`, `CD = 400`, `CM = 900`

---

## ✅ 解法①：前から処理して、次と比較（基本）

- 辞書を使って記号→値を高速に変換
- `s[i] < s[i+1]` の場合は減算、そうでなければ加算
- 最後の1文字だけループ外で加算する必要あり

### 🔹 特徴
- 素直で理解しやすい
- 前後の値を比較して処理する
- 実装時のオフバイワンに注意

- 時間計算量：O(n)
- 空間計算量：O(1)

---

## ✅ 解法②：逆から処理して、前と比較（簡潔版）

- `s` を逆順に処理
- 直前の値（`prev`）より小さければ減算、それ以外は加算
- 初期化した `prev = 0` によりロジックがシンプルに

### 🔹 特徴
- 条件が明快でコードが簡潔
- `prev` を更新するだけで済む
- Python の `reversed()` を活用して読みやすさアップ

- 時間計算量：O(n)
- 空間計算量：O(1)

---

## 💡 学び・気づき

- ローマ数字のルール（特に減算パターン）を事前に理解するのがカギ
- 辞書を使うと数値変換が簡単で高速
- 前から処理 or 後ろから処理、どちらでも解けるが後者はより簡潔
- 「隣との大小関係で加減算を決定する」戦略は他の文字列数値変換問題でも応用可能

---

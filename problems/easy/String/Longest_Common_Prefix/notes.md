# Longest Common Prefix

## 問題概要

- 文字列の配列 `strs` が与えられる
- すべての文字列に共通して含まれる最長の接頭辞 (prefix) を返す
- 共通する接頭辞がない場合は空文字列 `""` を返す

---

## 解法 1: 水平スキャン (Horizontal Scanning)

### 考え方・ポイント:
- 最初の文字列を基準として「共通部分」を保持し続ける方法
- 各文字列と共通部分（prefix）を一文字ずつ比較して、一致しなくなった地点で切り詰めていく
- `startswith()` を使わず、インデックス比較で同様の挙動を再現
- 配列の文字列数が増えると比較回数も増えるが、各文字は一度しか比較されないので効率的

---

## 解法 2: 垂直スキャン (Vertical Scanning)

### 考え方・ポイント:
- 配列を「列単位」で見ていく方法（縦にスキャン）
- 先頭の文字列の各文字位置ごとに、すべての文字列と比較
- インデックスが足りない or 文字が違うタイミングで終了
- 一致する間はそのインデックス位置までが共通接頭辞
- 文字列長の差を考慮して `i >= len(s)` のチェックが重要

---

## 難しかったこと・気づき

- `startswith()` の代わりに自前で文字比較を行うロジックを作ることは、思った以上にロジックの順序と条件処理が難しい
- `prefix[:i]` を `while` 内で毎回更新してしまうと、思ったように比較が進まない（更新タイミングに注意）
- 空文字列になったときの処理を忘れるとバグになりやすい（早期 return）
- 垂直スキャンでは、IndexError を避けるための `i >= len(s)` が肝心
- どちらの方法も、各文字列の「比較単位」を意識することで設計しやすくなる

---

## 感想

- 一見簡単そうに見える問題でも、実装を通じて「文字列処理の基本動作」「インデックス制御」「境界条件の見極め」など多くの要素が試される
- 自力で `startswith` を再実装できるようになるのは大きなスキルアップ
- 単なる解法だけでなく、エラーを防ぐ考え方も非常に重要